"""
Centralized Error Handling for Cloud-Native Applications
Provides consistent error responses, logging, and monitoring integration
"""

import traceback\nfrom typing import Dict, Any, Optional, Union\nfrom fastapi import HTTPException, Request, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom pydantic import ValidationError\nfrom sqlalchemy.exc import SQLAlchemyError, IntegrityError\nfrom redis.exceptions import RedisError\nfrom utils.cloud_logger import cloud_logger, get_correlation_id\nfrom utils.metrics import metrics\n\nclass ApplicationError(Exception):\n    \"\"\"Base application error class\"\"\"\n    \n    def __init__(self, message: str, error_code: str = \"APP_ERROR\", \n                 status_code: int = 500, details: Optional[Dict[str, Any]] = None):\n        self.message = message\n        self.error_code = error_code\n        self.status_code = status_code\n        self.details = details or {}\n        super().__init__(message)\n\nclass BusinessLogicError(ApplicationError):\n    \"\"\"Business logic validation error\"\"\"\n    \n    def __init__(self, message: str, error_code: str = \"BUSINESS_ERROR\", \n                 details: Optional[Dict[str, Any]] = None):\n        super().__init__(message, error_code, 400, details)\n\nclass AuthenticationError(ApplicationError):\n    \"\"\"Authentication related error\"\"\"\n    \n    def __init__(self, message: str = \"Authentication failed\", \n                 error_code: str = \"AUTH_ERROR\", \n                 details: Optional[Dict[str, Any]] = None):\n        super().__init__(message, error_code, 401, details)\n\nclass AuthorizationError(ApplicationError):\n    \"\"\"Authorization related error\"\"\"\n    \n    def __init__(self, message: str = \"Access denied\", \n                 error_code: str = \"AUTHZ_ERROR\", \n                 details: Optional[Dict[str, Any]] = None):\n        super().__init__(message, error_code, 403, details)\n\nclass ResourceNotFoundError(ApplicationError):\n    \"\"\"Resource not found error\"\"\"\n    \n    def __init__(self, message: str = \"Resource not found\", \n                 resource_type: str = \"resource\", resource_id: str = \"\", \n                 error_code: str = \"NOT_FOUND\"):\n        details = {\"resource_type\": resource_type, \"resource_id\": resource_id}\n        super().__init__(message, error_code, 404, details)\n\nclass ExternalServiceError(ApplicationError):\n    \"\"\"External service integration error\"\"\"\n    \n    def __init__(self, message: str, service_name: str, \n                 error_code: str = \"EXTERNAL_SERVICE_ERROR\", \n                 status_code: int = 502, \n                 details: Optional[Dict[str, Any]] = None):\n        details = details or {}\n        details[\"service_name\"] = service_name\n        super().__init__(message, error_code, status_code, details)\n\nclass RateLimitError(ApplicationError):\n    \"\"\"Rate limit exceeded error\"\"\"\n    \n    def __init__(self, message: str = \"Rate limit exceeded\", \n                 retry_after: Optional[int] = None,\n                 error_code: str = \"RATE_LIMIT_EXCEEDED\"):\n        details = {\"retry_after\": retry_after} if retry_after else {}\n        super().__init__(message, error_code, 429, details)\n\nclass ErrorHandler:\n    \"\"\"Centralized error handler\"\"\"\n    \n    @staticmethod\n    def create_error_response(\n        error: Exception,\n        request: Request,\n        status_code: int = 500,\n        error_code: str = \"INTERNAL_ERROR\",\n        message: str = \"Internal server error\",\n        details: Optional[Dict[str, Any]] = None\n    ) -> JSONResponse:\n        \"\"\"Create standardized error response\"\"\"\n        \n        correlation_id = get_correlation_id()\n        \n        # Create error response\n        error_response = {\n            \"error\": {\n                \"code\": error_code,\n                \"message\": message,\n                \"correlation_id\": correlation_id,\n                \"timestamp\": cloud_logger.logger.handlers[0].formatter.formatTime(\n                    cloud_logger.logger.makeRecord(\n                        cloud_logger.logger.name, 0, \"\", 0, \"\", (), None\n                    )\n                )\n            }\n        }\n        \n        # Add details if provided\n        if details:\n            error_response[\"error\"][\"details\"] = details\n        \n        # Log error with context\n        error_context = {\n            \"error_type\": type(error).__name__,\n            \"error_code\": error_code,\n            \"status_code\": status_code,\n            \"path\": request.url.path,\n            \"method\": request.method,\n            \"client_ip\": getattr(request.client, 'host', 'unknown') if request.client else 'unknown',\n            \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n            \"correlation_id\": correlation_id\n        }\n        \n        if details:\n            error_context[\"details\"] = details\n        \n        # Log at appropriate level\n        if status_code >= 500:\n            cloud_logger.error(f\"Server error: {message}\", **error_context)\n        elif status_code >= 400:\n            cloud_logger.warning(f\"Client error: {message}\", **error_context)\n        else:\n            cloud_logger.info(f\"Error response: {message}\", **error_context)\n        \n        # Record metrics\n        metrics.record_http_request(\n            method=request.method,\n            endpoint=request.url.path,\n            status_code=status_code,\n            duration=0  # Will be updated by middleware\n        )\n        \n        return JSONResponse(\n            status_code=status_code,\n            content=error_response,\n            headers={\"X-Correlation-ID\": correlation_id}\n        )\n\n# Global error handler instance\nerror_handler = ErrorHandler()\n\n# Exception handlers for FastAPI\nasync def application_error_handler(request: Request, exc: ApplicationError) -> JSONResponse:\n    \"\"\"Handle custom application errors\"\"\"\n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=exc.status_code,\n        error_code=exc.error_code,\n        message=exc.message,\n        details=exc.details\n    )\n\nasync def http_exception_handler(request: Request, exc: HTTPException) -> JSONResponse:\n    \"\"\"Handle FastAPI HTTP exceptions\"\"\"\n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=exc.status_code,\n        error_code=\"HTTP_ERROR\",\n        message=exc.detail,\n        details={\"status_code\": exc.status_code}\n    )\n\nasync def starlette_http_exception_handler(request: Request, exc: StarletteHTTPException) -> JSONResponse:\n    \"\"\"Handle Starlette HTTP exceptions\"\"\"\n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=exc.status_code,\n        error_code=\"HTTP_ERROR\",\n        message=exc.detail,\n        details={\"status_code\": exc.status_code}\n    )\n\nasync def validation_error_handler(request: Request, exc: RequestValidationError) -> JSONResponse:\n    \"\"\"Handle request validation errors\"\"\"\n    validation_details = {\n        \"validation_errors\": exc.errors(),\n        \"body\": exc.body\n    }\n    \n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=422,\n        error_code=\"VALIDATION_ERROR\",\n        message=\"Request validation failed\",\n        details=validation_details\n    )\n\nasync def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError) -> JSONResponse:\n    \"\"\"Handle SQLAlchemy database errors\"\"\"\n    error_code = \"DATABASE_ERROR\"\n    message = \"Database operation failed\"\n    status_code = 500\n    \n    # Handle specific database errors\n    if isinstance(exc, IntegrityError):\n        error_code = \"INTEGRITY_ERROR\"\n        message = \"Database integrity constraint violation\"\n        status_code = 409\n    \n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=status_code,\n        error_code=error_code,\n        message=message,\n        details={\"database_error\": str(exc)}\n    )\n\nasync def redis_error_handler(request: Request, exc: RedisError) -> JSONResponse:\n    \"\"\"Handle Redis connection/operation errors\"\"\"\n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=503,\n        error_code=\"CACHE_ERROR\",\n        message=\"Cache service unavailable\",\n        details={\"cache_error\": str(exc)}\n    )\n\nasync def generic_exception_handler(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"Handle unexpected exceptions\"\"\"\n    # Log the full traceback for debugging\n    cloud_logger.error(\n        f\"Unhandled exception: {str(exc)}\",\n        error_type=type(exc).__name__,\n        traceback=traceback.format_exc(),\n        path=request.url.path,\n        method=request.method\n    )\n    \n    return error_handler.create_error_response(\n        error=exc,\n        request=request,\n        status_code=500,\n        error_code=\"INTERNAL_ERROR\",\n        message=\"An unexpected error occurred\",\n        details={\"error_type\": type(exc).__name__}\n    )